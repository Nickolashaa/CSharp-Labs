# 1.	Понятие объектно-ориентированного программирования (ООП). Основные принципы ООП. Наследование, агрегация, композиция. Примеры реализации принципов ООП в ЯП C#.

ООП - парадигма программирования, в которой программа строится на основке объектов и их взаимодействия между ними.

Инкапсуляция - Возможность управления сложным объектом без понимания его структуры. Сокрытие внутренней реализации объекта, представление необходимого интерфейса. В C# для этого есть модификаторы доступа public, protected, private
```c#
public class BankAccount
{
    private decimal _balance;  // Поле скрыто

    public void Deposit(decimal amount) => _balance += amount;
    public decimal GetBalance() => _balance;
}
```
Наследование - Создание нового класса на основе уже созданного с возможностью расширения и/или изменения поведения.
```c#
public class Animal
{
    public void Eat() => Console.WriteLine("Eating...");
}

public class Dog : Animal
{
    public void Bark() => Console.WriteLine("Barking...");
}
```
Агрегация - Штука похожая на наследование, но объекты могут существовать независимо. 
```c#
public class Engine { }

public class Car
{   
    // Объект передается извне (например через конструктор)
    private Engine _engine;
    public Car(Engine engine) => _engine = engine;  // Агрегация
}
```
Композиция - Штука похожая на агрегацию, но более строгая. Часть не может существовать без целого.
```c#
public class House
{
    private Roof _roof = new Roof();  // Композиция
    
    public House() 
    {
        // _roof не может существовать без House
    }
}
```
Полифорфизм - Возможность объектов с одинаковым интерфейсом иметь разную реализацию. В C# реализуется через переопределение методов (virtual/override) и интерфейсы.
```c#
public class Shape
{
    public virtual void Draw() => Console.WriteLine("Drawing a shape");
}

public class Circle : Shape
{
    public override void Draw() => Console.WriteLine("Drawing a circle");
}
```
Абстрация - Выделение основных характеристик объекта, игнорируя несущественные детали. В C# реализуется с помощью абстрактных классов и интерфейсы
```c#
public abstract class Vehicle
{
    public abstract void Move();
}

public class Car : Vehicle
{
    public override void Move() => Console.WriteLine("Driving...");
}
```

# 2. Понятие класса. Основные элементы классов. Отличия класса и объекта.

Класс - шаблон для создания объектов. Класс определяет - данные (поля и свойства), методы, конструкторы. Если спросит чем поле отличается от свойства, то поле хранит данные объекта (обычно оно private), а свойство контроллирует доступ к поляем get/set.

```c#
private int _id; // Поле
public string Name { get; set; } // Свойство
```

Объект - реализация класса. Класс существует в коде, объект создается в памяти во время выполнения проги. Класс имеет несколько объектов. Объект - отдельная сущность.

# 3. Ссылочные и значимые типы данных. Примеры, объявление и инициализация переменных. Приведение ссылочных и значимых типов данных. Понтие nullable типов данных.

| Значимые типы                                                 | Ссылочные типы                                          |
|---------------------------------------------------------------|---------------------------------------------------------|
| int, double, float, short, перечисления, структуры и подобные | классы, объекты, строки, массивы, интерфейсы, делегаты, |
| Хранятся в стеке                                              | Хранятся в куче                                         |
| При присваивании значение копируется                          | При присваивании копируется ссылка                      |
| По умолчанию не могут быть Nullable, но можно сделать int?    | По умолчанию могут быть Nulllable                       |
|                                                               |                                                         |
Приведение типов
Значимые типы:
Неявное
```c#
int i = 10;
double d = i;  // Неявное приведение int → double
```
Явное
```c#
double d = 10.5;
int i = (int)d;  // Явное приведение double → int (i = 10)
```
Ссылочные типы:
Неявное
```c#
string s = "Hello";
object obj = s;  // string → object (автоматически)
```
явное
```c#
object obj = "Hello";
string s = (string)obj;  // object → string (требуется явное приведение)
```

# 4. Модификаторы доступа к элементам класса. Конструктор и финализатор. Насаледование конструкторов и финализаторов. Ключевые слова base и this.

```c#
var obj = new Person();
Console.WriteLine(obj.Name); // Конструктор по умолчанию + Статический конструктор
var obj2 = new Person("Alice", 25); // Пользовательский конструктор
Console.WriteLine(obj2.Name);
public class Person
{
    public string Name { get; }
    public int Age { get; }

    // Конструктор по умолчанию
    public Person()
    {
        Name = "Unknown";
        Age = 0;
    }

    // Пользовательский конструктор
    public Person(string name, int age)
    {
        Name = name;
        Age = age;
    }

    // Статический конструктор
    static Person()
    {
        Console.WriteLine("Класс Person загружен");
    }
    // Финализатор
    ~Person()
    {
        Console.WriteLine("Финализатор вызван");
    }
}
```
Конструкторы не наследуются, но можно вызвать конструктор отца через base
```c#
public class Animal
{
    public string Name { get; }

    public Animal(string name)
    {
        Name = name;
    }
}

public class Dog : Animal
{
    public int Age { get; }

    // Вызов конструктора базового класса через base
    public Dog(string name, int age) : base(name)
    {
        Age = age;
    }
}
```
this - это "ссылка" на текущий объект класса.
base - это "ссылка" на родителя текущего объекта класса.
Соответственно можно использовать например this.name = "Степа" - присвоили имя; base.GetElementById(); - вызвали метод у отца.

# 5. соска
